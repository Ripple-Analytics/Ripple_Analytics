#!/bin/bash
# =============================================================================
# Pre-commit Hook for Mental Models Desktop
# =============================================================================
# This hook prevents commits that contain Clojure errors that would cause
# runtime crashes like "Integer cannot be cast to IFn"
#
# Install: git config core.hooksPath .githooks
# =============================================================================

set -e

echo "ğŸ” Running pre-commit checks..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Check if clj-kondo is installed
if ! command -v clj-kondo &> /dev/null; then
    echo -e "${YELLOW}âš ï¸  clj-kondo not installed. Installing...${NC}"
    curl -sLO https://raw.githubusercontent.com/clj-kondo/clj-kondo/master/script/install-clj-kondo
    chmod +x install-clj-kondo
    sudo ./install-clj-kondo
    rm install-clj-kondo
fi

# Get list of staged Clojure files
STAGED_CLJ_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(clj|cljs|cljc)$' || true)

if [ -z "$STAGED_CLJ_FILES" ]; then
    echo -e "${GREEN}âœ“ No Clojure files staged${NC}"
    exit 0
fi

echo "Checking staged Clojure files:"
echo "$STAGED_CLJ_FILES"
echo ""

# Run clj-kondo on staged files
ERRORS_FOUND=0
for file in $STAGED_CLJ_FILES; do
    if [ -f "$file" ]; then
        echo -n "  Checking $file... "
        
        # Run clj-kondo and capture errors
        ERRORS=$(clj-kondo --lint "$file" 2>&1 | grep -E "error:" || true)
        
        if [ -n "$ERRORS" ]; then
            echo -e "${RED}FAILED${NC}"
            echo -e "${RED}$ERRORS${NC}"
            ERRORS_FOUND=1
        else
            echo -e "${GREEN}OK${NC}"
        fi
    fi
done

echo ""

# Check for specific dangerous patterns
echo "ğŸ” Checking for dangerous patterns..."

for file in $STAGED_CLJ_FILES; do
    if [ -f "$file" ]; then
        # Check for variable shadowing of 'count'
        if grep -n '\[count\s' "$file" > /dev/null 2>&1; then
            echo -e "${RED}âŒ ERROR in $file: Variable 'count' shadows clojure.core/count${NC}"
            echo "   This causes 'Integer cannot be cast to IFn' errors!"
            echo "   Rename to 'item-count' or 'model-count'"
            grep -n '\[count\s' "$file"
            ERRORS_FOUND=1
        fi
        
        # Check for variable shadowing of 'map'
        if grep -n '\[map\s' "$file" > /dev/null 2>&1; then
            echo -e "${RED}âŒ ERROR in $file: Variable 'map' shadows clojure.core/map${NC}"
            grep -n '\[map\s' "$file"
            ERRORS_FOUND=1
        fi
        
        # Check for unescaped regex in re-pattern
        if grep -n 're-pattern.*str.*\\s\*' "$file" | grep -v '\\\\s' > /dev/null 2>&1; then
            echo -e "${RED}âŒ ERROR in $file: Unescaped \\s in re-pattern${NC}"
            echo "   Use \\\\s* not \\s* inside (re-pattern (str ...))"
            ERRORS_FOUND=1
        fi
    fi
done

echo ""

if [ $ERRORS_FOUND -eq 1 ]; then
    echo -e "${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${RED}âŒ COMMIT BLOCKED: Clojure errors detected!${NC}"
    echo -e "${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo "Fix the errors above before committing."
    echo "To bypass (NOT RECOMMENDED): git commit --no-verify"
    echo ""
    exit 1
fi

echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${GREEN}âœ“ All pre-commit checks passed!${NC}"
echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
exit 0
